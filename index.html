<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rhythm Platformer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            touch-action: none;
            overflow: hidden;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #ff6b6b;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #game-container {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        canvas {
            border-radius: 5px;
            display: block;
        }

        .instructions {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #2a2a2a;
            border-radius: 10px;
            line-height: 1.6;
        }

        .instructions h2 {
            color: #4ecdc4;
            margin-bottom: 15px;
        }

        .instructions ul {
            list-style-position: inside;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 10px;
            color: #dddddd;
        }

        .key {
            background-color: #3a3a3a;
            padding: 2px 8px;
            border-radius: 4px;
            color: #ffffff;
            font-family: monospace;
            margin: 0 4px;
        }

        footer {
            margin-top: auto;
            padding: 20px;
            text-align: center;
            color: #666666;
        }

        #difficulty-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 42, 42, 0.95);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }

        #difficulty-menu h2 {
            color: #ff6b6b;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .difficulty-btn {
            display: block;
            width: 200px;
            margin: 15px auto;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }

        .difficulty-btn.easy {
            background-color: #4ecdc4;
            color: #1a1a1a;
        }

        .difficulty-btn.normal {
            background-color: #ffd93d;
            color: #1a1a1a;
        }

        .difficulty-btn.hard {
            background-color: #ff6b6b;
            color: #ffffff;
        }

        .difficulty-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <header>
        <h1>Rhythm Platformer</h1>
    </header>

    <div id="difficulty-menu">
        <h2>Select Difficulty</h2>
        <button class="difficulty-btn easy" onclick="startGame('easy')">Easy</button>
        <button class="difficulty-btn normal" onclick="startGame('normal')">Normal</button>
        <button class="difficulty-btn hard" onclick="startGame('hard')">Hard</button>
    </div>

    <div id="game-container"></div>

    <div class="instructions">
        <h2>How to Play</h2>
        <ul>
            <li>Press <span class="key">SPACE</span> or tap screen to jump</li>
            <li>Pass 100 obstacles to win!</li>
            <li>Avoid hitting obstacles from the sides</li>
            <li>You can land on top of obstacles</li>
        </ul>
    </div>

    <footer>
        <p>A Rhythm-based Platformer Game</p>
    </footer>

    <script>
    let difficulty = 'hard';
    let difficultySettings = {
        easy: { baseSpeed: 4, speedIncrease: 15 },
        normal: { baseSpeed: 5.5, speedIncrease: 20 },
        hard: { baseSpeed: 7, speedIncrease: 25 }
    };

    function startGame(selectedDifficulty) {
        difficulty = selectedDifficulty;
        document.getElementById('difficulty-menu').classList.add('hidden');
    }

    new p5(p => {
        let player;
        let obstacles = [];
        let ground;
        let obstaclesPassed = 0;
        let gameOver = false;
        let gameWon = false;
        let beatInterval = 500;
        let lastBeatTime = 0;
        let spritesheet;
        let platformSprites;
        let bgMusic;
        let backgroundImg;
        let highScore = 0;

        class Player {
            constructor() {
                this.x = 100;
                this.y = 300;
                this.velocity = 0;
                this.gravity = 0.8;
                this.jumpForce = -15;
                this.size = 30;
                this.isJumping = false;
                this.frameCount = 0;
                this.currentFrame = 0;
                this.animationSpeed = 0.2;
                this.spriteWidth = 32;
                this.spriteHeight = 32;
                this.totalFrames = 4;
            }

            getSprite() {
                this.frameCount += this.animationSpeed;
                this.currentFrame = Math.floor(this.frameCount) % this.totalFrames;
                return {
                    sx: this.currentFrame * this.spriteWidth,
                    sy: 0,
                    sw: this.spriteWidth,
                    sh: this.spriteHeight
                };
            }

            jump() {
                if (!this.isJumping) {
                    this.velocity = this.jumpForce;
                    this.isJumping = true;
                }
            }

            update() {
                this.velocity += this.gravity;
                this.y += this.velocity;

                if (this.y > ground - this.size/2) {
                    this.y = ground - this.size/2;
                    this.velocity = 0;
                    this.isJumping = false;
                }

                obstacles.forEach(obstacle => {
                    const bounds = obstacle.getBounds();
                    const playerBounds = this.getBounds();

                    // Only allow landing on platforms, not spikes
                    if (this.velocity > 0 && !obstacle.isSpike) {
                        const wasAbovePlatform = playerBounds.bottom - this.velocity <= bounds.top;
                        const isOverlappingX = playerBounds.right > bounds.left && playerBounds.left < bounds.right;

                        if (wasAbovePlatform && isOverlappingX && playerBounds.bottom >= bounds.top) {
                            this.y = bounds.top - this.size/2;
                            this.velocity = 0;
                            this.isJumping = false;
                        }
                    }
                });
            }

            draw() {
                const sprite = this.getSprite();
                p.push();
                p.translate(this.x - this.size/2, this.y - this.size/2);
                p.imageMode(p.CORNER);
                p.image(spritesheet, 0, 0, this.size, this.size,
                    sprite.sx, sprite.sy, sprite.sw, sprite.sh);
                p.pop();
            }

            getBounds() {
                return {
                    left: this.x - this.size/2,
                    right: this.x + this.size/2,
                    top: this.y - this.size/2,
                    bottom: this.y + this.size/2
                };
            }
        }

        class Obstacle {
            constructor() {
                const difficultyMultiplier = 1 + (obstaclesPassed / 50);
                const obstacleType = p.random();

                // 30% chance for spike
                this.isSpike = obstacleType < 0.3;

                if (this.isSpike) {
                    this.width = p.random(30, 50);
                    this.height = p.random(30, 50);
                } else {
                    const platformRoll = p.random();
                    const isNarrow = platformRoll < 0.3 * difficultyMultiplier;
                    const isExtraWide = platformRoll > 0.8;

                    if (isNarrow) {
                        this.width = p.random(20, 35);
                    } else if (isExtraWide) {
                        this.width = p.random(120, 200);
                    } else {
                        this.width = p.random(40, 80);
                    }

                    const maxJumpHeight = (player.jumpForce * player.jumpForce) / (2 * player.gravity);

                    if (isNarrow) {
                        this.height = p.random(40, maxJumpHeight * 0.6);
                        this.sprite = platformSprites.narrow;
                    } else if (isExtraWide) {
                        this.height = p.random(50, maxJumpHeight * 0.85);
                        this.sprite = platformSprites.wide;
                    } else {
                        this.height = p.random(45, maxJumpHeight * 0.75);
                        this.sprite = platformSprites.normal;
                    }
                }

                this.x = p.width;
                this.y = ground - this.height;
                const settings = difficultySettings[difficulty];
                const maxSpeedIncrease = 8;
                const speedIncrease = Math.min(obstaclesPassed / settings.speedIncrease, maxSpeedIncrease);
                this.speed = settings.baseSpeed + speedIncrease;
                this.passed = false;
            }

            update() {
                this.x -= this.speed;
                
                if (!this.passed && this.x < player.x) {
                    this.passed = true;
                    obstaclesPassed++;
                    if (obstaclesPassed >= 100) {
                        gameWon = true;
                        if (bgMusic) {
                            bgMusic.stop();
                        }
                    }
                }
            }

            draw() {
                if (this.isSpike) {
                    // Draw triangle spike
                    p.fill(200, 50, 50);
                    p.stroke(150, 30, 30);
                    p.strokeWeight(2);
                    p.triangle(
                        this.x, this.y + this.height,
                        this.x + this.width / 2, this.y,
                        this.x + this.width, this.y + this.height
                    );
                    p.noStroke();
                } else {
                    p.image(this.sprite, this.x, this.y, this.width, this.height);
                }
            }

            getBounds() {
                return {
                    left: this.x,
                    right: this.x + this.width,
                    top: this.y,
                    bottom: this.y + this.height
                };
            }
        }

        function checkCollision(a, b) {
            return !(a.right < b.left || a.left > b.right || 
                    a.bottom < b.top || a.top > b.bottom);
        }

        p.preload = () => {
            spritesheet = p.loadImage('./images/player.png');
            platformSprites = {
                narrow: p.loadImage('./images/narrow.png'),
                normal: p.loadImage('./images/normal.png'),
                wide: p.loadImage('./images/wide.png')
            };
            bgMusic = p.loadSound('./audio.mp3');
            backgroundImg = p.loadImage('./images/background.png');

            // Load high score from localStorage
            const savedScore = localStorage.getItem('rhythmPlatformerHighScore');
            if (savedScore) {
                highScore = parseInt(savedScore);
            }
        };

        function initGame() {
            ground = p.height - 50;
            player = new Player();
            obstacles = [];
            obstaclesPassed = 0;
            gameOver = false;
            gameWon = false;

            if (bgMusic) {
                bgMusic.stop();
                bgMusic.loop();
            }

            for (let i = 0; i < 3; i++) {
                obstacles.push(new Obstacle());
                obstacles[i].x = p.width + i * p.width/2;
            }
        }

        p.setup = () => {
            let canvasWidth = Math.min(800, window.innerWidth - 40);
            let canvasHeight = Math.min(400, window.innerHeight - 200);
            const canvas = p.createCanvas(canvasWidth, canvasHeight);
            canvas.parent('game-container');
            initGame();

            canvas.touchStarted(() => {
                if (!gameOver && !gameWon) {
                    player.jump();
                } else {
                    initGame();
                }
                return false;
            });
        };

        p.draw = () => {
            if (!gameOver && !gameWon) {
                p.background(30);
                p.image(backgroundImg, 0, 0, p.width, p.height);
                
                p.fill(80);
                p.noStroke();
                p.rect(0, ground, p.width, p.height - ground);
                
                let currentTime = p.millis();
                if (currentTime - lastBeatTime > beatInterval) {
                    lastBeatTime = currentTime;
                    p.image(backgroundImg, 0, 0, p.width, p.height);
                }
                
                player.update();
                player.draw();
                
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    obstacles[i].update();
                    obstacles[i].draw();

                    const playerBounds = player.getBounds();
                    const obstacleBounds = obstacles[i].getBounds();

                    // For spikes, any collision is fatal
                    // For platforms, only side collisions are fatal
                    const isAboveObstacle = playerBounds.bottom - player.velocity <= obstacleBounds.top;
                    if (obstacles[i].isSpike) {
                        if (checkCollision(playerBounds, obstacleBounds)) {
                            gameOver = true;
                            if (bgMusic) {
                                bgMusic.stop();
                            }
                            // Update high score
                            if (obstaclesPassed > highScore) {
                                highScore = obstaclesPassed;
                                localStorage.setItem('rhythmPlatformerHighScore', highScore);
                            }
                        }
                    } else {
                        if (!isAboveObstacle && checkCollision(playerBounds, obstacleBounds)) {
                            gameOver = true;
                            if (bgMusic) {
                                bgMusic.stop();
                            }
                            // Update high score
                            if (obstaclesPassed > highScore) {
                                highScore = obstaclesPassed;
                                localStorage.setItem('rhythmPlatformerHighScore', highScore);
                            }
                        }
                    }

                    if (obstacles[i].x + obstacles[i].width < 0) {
                        obstacles.splice(i, 1);
                    }
                }
                
                if (obstacles.length < 3) {
                    let lastObstacle = obstacles[obstacles.length - 1];
                    if (p.width - lastObstacle.x > p.width/2) {
                        obstacles.push(new Obstacle());
                    }
                }
                
                p.fill(0);
                p.textSize(24);
                p.textAlign(p.LEFT);
                p.text(`Obstacles: ${obstaclesPassed}/100`, 20, 40);
            } else if (gameWon) {
                // Improved Win Screen
                p.background(30);
                p.image(backgroundImg, 0, 0, p.width, p.height);

                // Semi-transparent overlay
                p.fill(0, 0, 0, 180);
                p.rect(0, 0, p.width, p.height);

                // Animated glow effect
                let glowSize = Math.sin(p.frameCount * 0.05) * 10 + 10;
                p.fill(255, 215, 0, 100);
                p.textSize(64 + glowSize);
                p.textAlign(p.CENTER, p.CENTER);
                p.text('YOU WON!', p.width/2, p.height/2 - 80);

                // Main title
                p.fill(255, 215, 0);
                p.textSize(64);
                p.text('YOU WON!', p.width/2, p.height/2 - 80);

                // Stats box
                p.fill(42, 42, 42, 220);
                p.rect(p.width/2 - 150, p.height/2 - 20, 300, 100, 10);

                // Score
                p.fill(78, 205, 196);
                p.textSize(20);
                p.text('Score', p.width/2, p.height/2);
                p.fill(255);
                p.textSize(32);
                p.text('100 / 100', p.width/2, p.height/2 + 30);

                // High Score
                p.fill(255, 107, 107);
                p.textSize(18);
                p.text(`High Score: ${highScore}`, p.width/2, p.height/2 + 60);

                // Instructions
                p.fill(200);
                p.textSize(20);
                p.text('Press SPACE to play again', p.width/2, p.height - 50);
            } else if (gameOver) {
                // Improved Game Over Screen
                p.background(30);
                p.image(backgroundImg, 0, 0, p.width, p.height);

                // Semi-transparent overlay
                p.fill(0, 0, 0, 180);
                p.rect(0, 0, p.width, p.height);

                // Title with glow
                let glowSize = Math.sin(p.frameCount * 0.05) * 5 + 5;
                p.fill(255, 50, 50, 100);
                p.textSize(56 + glowSize);
                p.textAlign(p.CENTER, p.CENTER);
                p.text('GAME OVER', p.width/2, p.height/2 - 80);

                p.fill(255, 107, 107);
                p.textSize(56);
                p.text('GAME OVER', p.width/2, p.height/2 - 80);

                // Stats box
                p.fill(42, 42, 42, 220);
                p.rect(p.width/2 - 150, p.height/2 - 20, 300, 120, 10);

                // Your Score
                p.fill(78, 205, 196);
                p.textSize(20);
                p.text('Your Score', p.width/2, p.height/2);
                p.fill(255);
                p.textSize(42);
                p.text(obstaclesPassed, p.width/2, p.height/2 + 35);

                // High Score
                const isNewRecord = obstaclesPassed > 0 && obstaclesPassed === highScore;
                if (isNewRecord) {
                    p.fill(255, 215, 0);
                    p.textSize(16);
                    p.text('NEW RECORD!', p.width/2, p.height/2 + 70);
                } else {
                    p.fill(255, 107, 107);
                    p.textSize(18);
                    p.text(`High Score: ${highScore}`, p.width/2, p.height/2 + 70);
                }

                // Difficulty display
                p.fill(150);
                p.textSize(14);
                p.text(`Difficulty: ${difficulty.toUpperCase()}`, p.width/2, p.height/2 + 90);

                // Instructions
                p.fill(200);
                p.textSize(20);
                p.text('Press SPACE to restart', p.width/2, p.height - 50);
            }
        };

        p.keyPressed = () => {
            if (p.keyCode === 32) {
                if (!gameOver && !gameWon) {
                    player.jump();
                } else {
                    initGame();
                }
            }
        };
    });
    </script>
</body>
</html>